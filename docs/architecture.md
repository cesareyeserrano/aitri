# Aitri: Architecture and Operating Model

## Purpose
Aitri is a **CLI-first, spec-driven software factory** — a complete SDLC engine that transforms ideas into verified, functional software.

It is designed for direct terminal use by humans and for operation by AI agents (Claude, Codex, OpenCode, others) under a controlled execution contract.

Core model:
- Human defines intent and approves at every gate
- Aitri enforces workflow, structure, traceability, and orchestrates the full delivery cycle
- AI agents (Claude, Codex, OpenCode) execute implementation tasks inside explicit constraints generated by Aitri
- Aitri verifies delivered software against declared specifications
- Requirements and specifications are authored by the human owner; Aitri does not invent requirements

Factory model:
- Aitri is the **plant engineer** — directs, validates, and certifies
- AI agents are the **workers** — implement code following Aitri's structured briefs
- The factory cycle is closed: `idea → spec → plan → scaffold → implement → verify → deliver`

## Product Positioning
Aitri is:
- A spec-driven software factory with closed delivery cycle
- A deterministic workflow engine that orchestrates AI-assisted implementation
- A reusable skill context that generates structured implementation briefs for AI agents
- A verification engine that maps test results to declared specifications

Aitri is not:
- A standalone code generator (it directs AI agents, not generates code itself)
- A replacement for product or architecture ownership
- A system that bypasses human approval
- A documentation-only tool — it delivers functional, verified software

## Non-Negotiable Principles
1. Spec first: no implementation without a written specification.
2. Approved spec required: no downstream artifacts without `specs/approved/<feature>.md`.
3. Explicit gates: write or destructive actions require a plan and approval.
4. Traceability required: Spec -> Backlog -> Tests -> Implementation.
5. Human authority: final decisions always remain with the human owner.
6. Requirement source integrity: requirements must come from explicit user input; inferred requirements are rejected.

## SDLC Coverage Target
Under human supervision, Aitri covers the complete software delivery lifecycle:

### Pre-Go Phase (Governance)
1. Discovery and requirement capture (`discover`)
2. Formal specification (`draft`, `approve`)
3. Planning with real content generation — concrete stories, tests, architecture (`plan`)
4. Traceability and quality validation (`validate`)
5. Runtime verification (`verify`)
6. Policy enforcement (`policy`)
7. Human approval gate (`handoff`, `go`)

### Post-Go Phase (Factory)
8. Project scaffold generation — executable test stubs, interface contracts, config (`scaffold`)
9. Implementation orchestration — structured briefs for AI agents, ordered by dependency (`implement`)
10. Closed-loop verification — TC-to-executable mapping, FR coverage reporting (`verify`)
11. Delivery gate — all FRs covered, all TCs passing, confidence threshold met (`deliver`)

## Scope Boundaries (Current)
In scope:
- CLI-first operation with closed delivery cycle
- deterministic command flow from idea to delivered software
- traceability and quality gates at every phase
- agent skill support under human control
- real content generation (concrete stories, tests, architecture from spec data)
- project scaffold generation (executable tests, interface stubs, config)
- structured implementation briefs for AI agents
- closed-loop verification (TC-to-executable mapping, FR coverage)
- delivery gate with confidence threshold
- implementation/deployment assistance with explicit human approval

Out of scope:
- autonomous multi-agent orchestration without human gates
- dashboard-first operation
- mandatory external SaaS integrations
- opaque scoring systems without deterministic controls
- automatic production deployment without explicit human confirmation
- direct code generation by Aitri (AI agents implement, Aitri directs)

Definition of done baseline:
1. End-to-end CLI works from idea to delivered software in greenfield and brownfield projects.
2. Generated backlogs and tests contain real content derived from spec, not placeholders.
3. Scaffold produces executable test stubs and interface contracts traced to spec.
4. Implementation briefs provide AI agents with complete, ordered context per story.
5. Verification maps test results to TC-* declarations and reports FR coverage.
6. Delivery gate blocks when FRs are uncovered or TCs are failing.
7. Validation and verification fail clearly when quality gates are not met.
8. Status/handoff guidance is deterministic across all phases.
9. Documentation preserves continuity without relying on one maintainer.
10. Agent skills execute full factory flow without bypassing gates.

## Stabilization State (2026-02-16)
- Critical stabilization window: CLOSED (H-001/H-002/H-003 verified)
- Phase G (Production Quality Hardening): baseline delivered
- Phase H (Software Factory Transformation): IN PROGRESS
- Source of truth: `docs/STRATEGY_EXECUTION.md`

## Artifact Topology
Standard project structure (pre-go):
- `specs/drafts/`
- `specs/approved/`
- `docs/discovery/`
- `docs/plan/`
- `backlog/<feature>/backlog.md`
- `tests/<feature>/tests.md`
- `docs/verification/<feature>.json`
- `docs/policy/<feature>.json`

Factory artifacts (post-go):
- `src/` — scaffolded project structure (components, services, models, routes)
- `tests/<feature>/generated/` — executable test stubs traced to TC-*
- `docs/implementation/<feature>/US-<n>.md` — per-story implementation briefs
- `docs/implementation/<feature>/IMPLEMENTATION_ORDER.md` — dependency-ordered execution plan
- `docs/delivery/<feature>.json` — machine-readable delivery evidence
- `docs/delivery/<feature>.md` — human-readable delivery report

Extended artifacts:
- architecture notes per feature
- release/deploy runbooks
- operational checklists

## Command-Level Flow (Complete Factory)

### Pre-Go Phase (Governance and Planning)
1. `aitri init` — initialize project structure
2. `aitri draft` — create draft spec from idea
3. `aitri approve` — validate and approve spec
4. `aitri discover` — generate discovery artifact with real interview data
5. `aitri plan` — generate plan, backlog (real stories), and tests (real cases) from spec
6. `aitri validate` — verify traceability, coverage, and persona gates
7. `aitri verify` — execute runtime verification
8. `aitri policy` — run managed policy checks
9. `aitri handoff` — present handoff status
10. human GO/NO-GO decision
11. `aitri go` — enter implementation mode (only after GO)

### Post-Go Phase (Factory Execution)
12. `aitri scaffold` — generate project structure, executable test stubs, interface contracts
13. `aitri implement` — generate ordered implementation briefs for AI agents
14. AI agent implements each US-* brief following Aitri's instructions
15. `aitri verify` — (enhanced) map test results to TC-*, report FR/US coverage
16. Repeat 14-15 per story until all US-* are implemented
17. `aitri deliver` — final gate: all FRs covered, all TCs passing, confidence met

## Agent Integration Model
Aitri is consumed as a skill by AI agents. In the factory model, agents are the **implementation workers** directed by Aitri's structured briefs.

Target environments:
- Claude (Claude Code)
- Codex
- OpenCode
- Other terminal-capable agents

Agent contract (pre-go):
- Execute one SDLC step at a time
- Respect gates and approval points
- Do not invent parallel workflows outside Aitri
- Report outcomes and the next recommended step

Agent contract (post-go / factory execution):
- Run `aitri scaffold` to generate project skeleton
- Run `aitri implement` to receive ordered implementation briefs
- Implement each US-* brief in the order specified by `IMPLEMENTATION_ORDER.md`
- After each US-*, run `aitri verify` to confirm TC-* pass
- Use scaffold interface stubs as contracts — do not change function signatures without spec update
- Do not skip stories or change implementation order
- When all stories pass: run `aitri deliver` for final gate

## Persona Model
Personas are structured SDLC lenses, not autonomous personalities.

Minimum perspectives:
- Discovery: problem framing, constraints, dependencies, measurable outcomes
- Product: value, scope, acceptance clarity
- Architect: boundaries, decisions, NFRs, risks
- Developer: implementation strategy, maintainability
- QA: testability, negative/edge coverage, quality gates
- Security (cross-cutting): threats and controls
- UX/UI (optional for user-facing features): usability, accessibility baseline, interaction quality

## Governance and Anti-Drift
The `docs/` folder is long-term memory and the verification baseline.

Any change in philosophy, scope, or workflow must update:
1. `docs/architecture.md`
2. `docs/EXECUTION_GUARDRAILS.md`
3. `docs/STRATEGY_EXECUTION.md`
4. `docs/PROGRESS_CHECKLIST.md`

If code and docs conflict, resolve the conflict explicitly before continuing roadmap work.
