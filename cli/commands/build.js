import fs from "node:fs";
import path from "node:path";
import { parseApprovedSpec } from "./spec-parser.js";
import { extractSection } from "../lib.js";
import {
  createTestStub,
  createInterfaceStub,
  detectStackFamily,
  parseTestCases,
  readTemplate,
  slugify
} from "./scaffold.js";
import {
  parseUserStories,
  parseTcMapByStory,
  buildImplementationOrder,
  buildBriefContent,
  parseQualityConstraints,
  parseImplementationHints,
  parseResourceStrategy,
  scanProjectAssets
} from "./implement.js";
import { runVerification } from "./runtime.js";

function readJsonFile(file) {
  try {
    return JSON.parse(fs.readFileSync(file, "utf8"));
  } catch {
    return null;
  }
}

function writeFile(file, content) {
  fs.mkdirSync(path.dirname(file), { recursive: true });
  fs.writeFileSync(file, content, "utf8");
}

function scaffoldTemplatesByStack(stackFamily) {
  if (stackFamily === "python") {
    return { test: readTemplate("python-test.py.tpl"), iface: readTemplate("python-interface.py.tpl") };
  }
  if (stackFamily === "go") {
    return { test: readTemplate("go-test.go.tpl"), iface: readTemplate("go-interface.go.tpl") };
  }
  return { test: readTemplate("node-test.js.tpl"), iface: readTemplate("node-interface.js.tpl") };
}

function parseArchitectureComponents(planContent) {
  const architecture = extractSection(planContent, "## 5. Architecture (Architect Persona)");
  const componentsSection = architecture
    ? (() => {
      const match = architecture.match(/### Components([\s\S]*?)(?=\n###\s|$)/i);
      return match ? match[1] : "";
    })()
    : "";
  return String(componentsSection || "")
    .split("\n")
    .map((line) => line.trim())
    .filter((line) => /^-\s+/.test(line))
    .map((line) => line.replace(/^-\s+/, "").trim())
    .filter(Boolean);
}

function scaffoldForStory({ story, allTestCases, tcMapByStory, root, stackFamily, feature, templates, parsedSpec }) {
  const storyTcIds = new Set((tcMapByStory[story.id] || []).map((tc) => tc.id));
  const storyTcs = allTestCases.filter((tc) => storyTcIds.has(tc.id));
  const writtenTests = storyTcs.map((tc) => createTestStub({
    root,
    stackFamily,
    feature,
    tc,
    testTemplate: templates.test,
    parsedSpec
  }));
  const storyFrIds = new Set(story.frIds || []);
  const interfaceRules = (parsedSpec.functionalRules || []).filter((fr) => storyFrIds.has(fr.id));
  const writtenInterfaces = interfaceRules.map((fr) => createInterfaceStub({
    root,
    stackFamily,
    fr,
    ifaceTemplate: templates.iface
  }));
  return {
    testFiles: writtenTests.map((f) => path.relative(root, f)),
    interfaceFiles: writtenInterfaces.map((f) => path.relative(root, f))
  };
}

function findScaffoldReferences(story, manifest) {
  const storyToken = String(story.id || "").toLowerCase().replace(/^us-/, "tc-");
  const testFiles = (manifest?.testFiles || []).filter((file) => {
    const lower = String(file).toLowerCase();
    return !storyToken || lower.includes(storyToken);
  });
  const frTokens = new Set((story.frIds || []).map((fr) => fr.toLowerCase().replace(/[^a-z0-9]+/g, "")));
  const interfaceFiles = (manifest?.interfaceFiles || []).filter((file) => {
    const normalized = String(file).toLowerCase().replace(/[^a-z0-9]+/g, "");
    return frTokens.size === 0 || [...frTokens].some((token) => normalized.includes(token));
  });
  return { testFiles: testFiles.slice(0, 6), interfaceFiles: interfaceFiles.slice(0, 6) };
}

function buildOrderContent({ feature, orderedStories, tcMapByStory }) {
  const rows = orderedStories.map((story, index) => {
    const tcCount = (tcMapByStory[story.id] || []).length;
    return `${index + 1}. ${story.id} (dependencyScore=${story.dependencyScore}, tcCount=${tcCount})`;
  }).join("\n");

  return `# Implementation Order: ${feature}

Generated by \`aitri build\`.

Dependency-sort policy:
- Lower dependencyScore executes first (data/model -> service -> UI/integration).
- Higher TC linkage breaks ties (stories with more verification surface first).
- US numeric order resolves remaining ties.

## Ordered Stories
${rows}
`;
}

function verifyForStory({ story, tcMapByStory, root, feature, verifyCmd }) {
  const result = runVerification({ root, feature, verifyCmd });
  const storyTcIds = new Set((tcMapByStory[story.id] || []).map((tc) => tc.id));
  const tcCoverage = result.tcCoverage || {};
  const mapped = tcCoverage.mapped || {};
  let passing = 0;
  let total = 0;
  for (const tcId of storyTcIds) {
    total++;
    if (mapped[tcId] && mapped[tcId].found) passing++;
  }
  return {
    ok: result.ok,
    storyId: story.id,
    totalTc: total,
    passingTc: passing,
    fullResult: result
  };
}

export async function runBuildCommand({
  options,
  getProjectContextOrExit,
  confirmProceed,
  printCheckpointSummary,
  runAutoCheckpoint,
  exitCodes
}) {
  const { OK, ERROR, ABORTED } = exitCodes;
  const project = getProjectContextOrExit();

  const rawFeature = String(options.feature || options.positional[0] || "").trim();
  let feature = rawFeature;
  if (!feature) {
    try {
      const { getStatusReport } = await import("./status.js");
      const report = getStatusReport({ root: process.cwd(), feature: null });
      feature = report.approvedSpec?.feature || null;
    } catch {
      feature = null;
    }
  }

  if (!feature) {
    console.log("Feature name is required. Use --feature <name>.");
    return ERROR;
  }

  const { normalizeFeatureName } = await import("../lib.js");
  feature = normalizeFeatureName(feature);
  if (!feature) {
    console.log("Invalid feature name. Use kebab-case (example: user-login).");
    return ERROR;
  }

  const goMarkerFile = project.paths.goMarkerFile(feature);
  if (!fs.existsSync(goMarkerFile)) {
    console.log("BUILD BLOCKED: go gate was not completed for this feature.");
    console.log(`Run first: aitri go --feature ${feature} --yes`);
    return ERROR;
  }

  const approvedFile = project.paths.approvedSpecFile(feature);
  const backlogFile = project.paths.backlogFile(feature);
  const testsFile = project.paths.testsFile(feature);
  const planFile = project.paths.planFile(feature);
  const required = [approvedFile, backlogFile, testsFile, planFile];
  const missing = required.filter((f) => !fs.existsSync(f));
  if (missing.length > 0) {
    console.log("BUILD BLOCKED: missing required artifacts.");
    missing.forEach((f) => console.log(`- ${path.relative(process.cwd(), f)}`));
    return ERROR;
  }

  const approvedSpec = fs.readFileSync(approvedFile, "utf8");
  const backlogContent = fs.readFileSync(backlogFile, "utf8");
  const testsContent = fs.readFileSync(testsFile, "utf8");
  const planContent = fs.readFileSync(planFile, "utf8");
  const parsedSpec = parseApprovedSpec(approvedSpec, { feature });
  const stackFamily = detectStackFamily(parsedSpec);
  const allTestCases = parseTestCases(testsContent);
  const stories = parseUserStories(backlogContent);
  if (stories.length === 0) {
    console.log("BUILD BLOCKED: backlog has no US-* entries.");
    return ERROR;
  }

  const tcMapByStory = parseTcMapByStory(testsContent);
  const quality = parseQualityConstraints(planContent);
  const hints = parseImplementationHints(planContent);
  const resourceStrategy = parseResourceStrategy(approvedSpec);
  const projectAssets = scanProjectAssets(process.cwd());
  const ordered = buildImplementationOrder(stories, tcMapByStory);
  const templates = scaffoldTemplatesByStack(stackFamily);

  const storyFilter = options.story ? options.story.trim().toUpperCase() : null;
  const targetStories = storyFilter
    ? ordered.filter((s) => s.id === storyFilter)
    : ordered;

  if (storyFilter && targetStories.length === 0) {
    console.log(`BUILD BLOCKED: story ${storyFilter} not found in backlog.`);
    console.log(`Available stories: ${ordered.map((s) => s.id).join(", ")}`);
    return ERROR;
  }

  const implementationDir = project.paths.implementationFeatureDir(feature);
  const orderFile = project.paths.implementationOrderFile(feature);

  console.log("PLAN:");
  console.log("- Read: " + path.relative(process.cwd(), approvedFile));
  console.log("- Read: " + path.relative(process.cwd(), backlogFile));
  console.log("- Read: " + path.relative(process.cwd(), testsFile));
  console.log("- Read: " + path.relative(process.cwd(), planFile));
  console.log(`- Build: ${targetStories.length} stories (scaffold + brief${options.noVerify ? "" : " + verify"})`);

  const proceed = await confirmProceed(options);
  if (proceed === null) {
    console.log("Non-interactive mode requires --yes for commands that modify files.");
    return ERROR;
  }
  if (!proceed) {
    console.log("Aborted.");
    return ABORTED;
  }

  fs.mkdirSync(implementationDir, { recursive: true });
  const existingScaffoldFile = path.join(implementationDir, "scaffold-manifest.json");
  const existingScaffold = readJsonFile(existingScaffoldFile) || { testFiles: [], interfaceFiles: [], baseConfigs: [] };
  const completedStories = [];
  const pendingStories = [];
  const storyResults = [];

  for (const story of targetStories) {
    console.log(`\n--- ${story.id} ---`);

    const scaffoldResult = scaffoldForStory({
      story, allTestCases, tcMapByStory,
      root: process.cwd(), stackFamily, feature, templates, parsedSpec
    });
    existingScaffold.testFiles = [...new Set([...(existingScaffold.testFiles || []), ...scaffoldResult.testFiles])];
    existingScaffold.interfaceFiles = [...new Set([...(existingScaffold.interfaceFiles || []), ...scaffoldResult.interfaceFiles])];

    const references = findScaffoldReferences(story, existingScaffold);
    const previous = ordered.slice(0, ordered.indexOf(story)).map((s) => s.id);
    const dependencyNotes = previous.length > 0 ? `Implement after ${previous.join(", ")}` : "No previous story dependency";
    const linkedTc = tcMapByStory[story.id] || [];

    const brief = buildBriefContent({
      feature, story, parsedSpec, quality, hints,
      linkedTc, references,
      dependencies: dependencyNotes,
      resourceStrategy, projectAssets
    });
    const briefFile = path.join(implementationDir, `${story.id}.md`);
    writeFile(briefFile, brief);
    console.log(`${story.id} scaffolded + brief generated`);

    let verified = false;
    if (!options.noVerify) {
      const verifyResult = verifyForStory({
        story, tcMapByStory,
        root: process.cwd(), feature,
        verifyCmd: options.verifyCmd
      });
      verified = verifyResult.ok;
      console.log(`${story.id} verify: ${verified ? "PASS" : "FAIL"} (${verifyResult.passingTc}/${verifyResult.totalTc} TCs)`);
    }

    storyResults.push({
      id: story.id,
      brief: path.relative(process.cwd(), briefFile),
      scaffoldFiles: [...scaffoldResult.testFiles, ...scaffoldResult.interfaceFiles],
      verified
    });

    if (verified || options.noVerify) {
      completedStories.push(story.id);
    } else {
      pendingStories.push(story.id);
    }
  }

  existingScaffold.feature = feature;
  existingScaffold.stackFamily = stackFamily;
  existingScaffold.generatedAt = new Date().toISOString();
  writeFile(existingScaffoldFile, JSON.stringify(existingScaffold, null, 2));

  writeFile(orderFile, buildOrderContent({ feature, orderedStories: ordered, tcMapByStory }));

  const buildManifestFile = project.paths.buildManifestFile(feature);
  const existingBuildManifest = readJsonFile(buildManifestFile) || {};
  const previousCompleted = existingBuildManifest.completedStories || [];
  const allCompleted = [...new Set([...previousCompleted, ...completedStories])];
  const allPending = ordered.map((s) => s.id).filter((id) => !allCompleted.includes(id));

  const buildManifest = {
    schemaVersion: 1,
    feature,
    generatedAt: new Date().toISOString(),
    completedStories: allCompleted,
    pendingStories: allPending,
    stories: storyResults
  };
  writeFile(buildManifestFile, JSON.stringify(buildManifest, null, 2));

  const implementManifestFile = path.join(implementationDir, "implement-manifest.json");
  writeFile(implementManifestFile, JSON.stringify({
    feature,
    generatedAt: new Date().toISOString(),
    stories: ordered.map((story, index) => ({
      id: story.id,
      order: index + 1,
      dependencyScore: story.dependencyScore,
      brief: path.relative(process.cwd(), path.join(implementationDir, `${story.id}.md`)),
      testCases: (tcMapByStory[story.id] || []).map((tc) => tc.id)
    })),
    orderFile: path.relative(process.cwd(), orderFile)
  }, null, 2));

  console.log(`\nBuild complete: ${completedStories.length} completed, ${pendingStories.length} pending`);
  console.log(`- Manifest: ${path.relative(process.cwd(), buildManifestFile)}`);
  console.log(`- Order: ${path.relative(process.cwd(), orderFile)}`);
  printCheckpointSummary(runAutoCheckpoint({
    enabled: options.autoCheckpoint,
    phase: "build",
    feature
  }));
  return OK;
}
